---
layout: post
title: Testing Improvements
---

After getting my tests looked at, it was pointed out to me that they're not very thorough and although they do all pass when the program is properly working, when they failed there was no easy way to tell exactly where the program was going wrong. My goal is to correct this and begin to add a lot more tests.<br> I began by revamping my computer_spec file, starting with a clear lack of tests for any board size greater than 3x3. I used essentially the same tests as my 3x3 modified for a 4x4 board and decided to use 
<br>`context "When board 4x4 do"` 
This seemed like an ideal way to tell if any sized board could be used with the same methods. While being thorough enough to not only fail, but pinpoint exactly the issue.
<br><br>
The second issue I decided to address with testing was how I went about testing my algorithm to determine what the possible solutions were for a victory. This is the original method...
<br>

{% highlight ruby %}

  def possible_wins(board_length)
    per_row = Math.sqrt(board_length)
    possible = []
    (0...board_length).each do |i|
      possible.push(i)
    end
    
    possible = possible.each_slice(per_row).to_a
    vertical = []
    (0...per_row).each do |row|
      vertical = []
      (0...per_row).each do |index|
        row_array = possible[index]
        vertical.push(row_array[row])
      end
      possible.push(vertical)
    end
    diag = []
    if ((board_length % 2) == 1)
      diag = []
      row = 0
      (0...per_row).each do |column|
        row_array = possible[column]
        diag.push(row_array[row])
        row = row + 1
      end
      possible.push(diag)
      diag = []
      row = per_row - 1
      (0...per_row).each do |column|
        row_array = possible[column]
        diag.push(row_array[row])
        row = row - 1
      end
      possible.push(diag)
    end
    return possible
  end
{% endhighlight %}
<br>
Looking at this code, it's difficult to comprehend and even more difficult to test. So I decided to make a few changes, and in the end isolated it into 4 seperate functions, one that finds the rows, one that finds the columns, and a third that finds the diagonals, with finally the fourth combining the results of the others, here's that code...

{% highlight ruby %}
	def get_horizontal_wins
		board_length = @board.length
		per_row = Math.sqrt(board_length)
		possible = []
		(0...board_length).each do |i|
			possible.push(i)
		end

		possible = possible.each_slice(per_row).to_a
	end

	def get_vertical_wins(horizontal)
		vertical = []
		possible = []
		board_length = @board.length
		per_row = Math.sqrt(board_length)
		(0...per_row).each do |row|
			vertical = []
			(0...per_row).each do |index|
				row_array = horizontal[index]
				vertical.push(row_array[row])
			end
			possible.push(vertical)
		end
		return possible
	end

	def get_diagonal_wins(possible)
		board_length = @board.length
		per_row = Math.sqrt(board_length)
		diag = []
		if ((board_length % 2) == 1)
			diag = []
			row = 0
			(0...per_row).each do |column|
				row_array = possible[column]
				diag.push(row_array[row])
				row = row + 1
			end
			possible.push(diag)
			diag = []
			row = per_row - 1
			(0...per_row).each do |column|
				row_array = possible[column]
				diag.push(row_array[row])
				row = row - 1
			end
			possible.push(diag)
		end
	end

	def possible_wins
		possible = get_horizontal_wins
		possible = possible + get_vertical_wins(possible)
		possible = possible + get_diagonal_wins(possible)
		return possible
	end
{% endhighlight %}

This shows just how important testing your code really is. Not only did testing point out a method that was way too large and definitely had more than one responsibility, but also encouraged the writing of readable code that facilitated simple testing. Even though this post is focused on testing it demonstrates how testing as you write is a crucial component in writing clean codel