---
layout: post
title: SOLID Principles 
---

Recently I've spent some time reading about the <a href= "http://en.wikipedia.org/wiki/SOLID_(object-oriented_design)">SOLID Principles</a>, and I figure this post would be a great way for my blog to hit the ground running. And plan to talk a little bit about each principle and why they're important in software development.<br><br>


The first principle is the <a href= "http://en.wikipedia.org/wiki/Single_responsibility_principle">Single Responsibility Principle.</a> This principle's message is rather
Explicit, but basically each project should be separated into parts with each part serving only one 'responsibility' or a reason to change. The single responsibility principle is very important in developing clean code because it allows you to make isolate every part of your program and keeps each individual class more directed and
Less cluttered and confusing. Without implementing this principle it seems very easily to unintentionally change a part of your program when changing a different
Incorporated part. I believe the single responsibility principle is definitely one that I need to work on implementing better in my programming, I have the bad habit
Of getting ahead of myself to try to get a certain feature to work and hard-code things that I probably shouldn't. To demonstate this principle take a look at the following code.
<br>
{% highlight java %}
public class CalculateShape {
    Shape shape;
    public CalculateShape(Shape shape)
    {
        this.shape = shape;
    }

    public void getArea()
    {
        return shape.getArea();
    }
}

public class ChangeShapeDimensions {
    Shape shape;
    public ChangeShapeDimensions(Shape shape)
    {
        this.shape = shape;
    }

    public void SetX(double newX)
    {
        shape.setX(newX)
    }
}

{% endhighlight %}
<br>
As you can see, the code is in two classes, each with a descriptive name and a clear function. How would the code be different if the class was instead called 'MyShape'? It simply just wouldn't be as clear, and although you may still know it's features without looking at an interface you most likely won't always be the only person looking at your code so it's important to make everything clear.
<br>
<br>
The second principle is the <a href= "http://en.wikipedia.org/wiki/Open/closed_principle">Open/Closed Principle.</a> To me, this principle sounds a lot like "Do the work now, so you don't have to later." A good example of this is any object in java that implements comparable, you could go into your own classes, look at attributes of the objects that allow you to differentiate them and write a get method, compare the two and return the correct value, or you could just implement comparable, write a compareTo that works for all instances of the object, making it very easy to change if more information is given, etc. In my current version of <a href= "https://github.com/tcmcgee/TicTacToeRuby">Ruby TicTacToe</a> I really need to apply this principle to my output system, which not only is dependent on the console but also allows for very little abstraction if I wanted to play on a webserver or something similar. Applying the Open/Closed principle is a powerful way to keep your code clean and easy to maintain no matter what's thrown at it.The code example above also applys to this principle, in each objects instantiation. Instead of being hard coded for each shape (RectangleCalculator, etc.) they just take a shape that is most likely abstract, which is the parent of many other objects each with a unique way to calculate the area defined within each child class.
<br>
<br>
The <a href = "http://en.wikipedia.org/wiki/Liskov_substitution_principle"> Liskov substitution principle</a> is a simple one, basically if any object is a subtype of another object, the object extending the original object shouldn't lose any of it's functionality and should behave similarly when called upon to serve a similar purpose. This principle is easier demonstrated then explained, please reference the following code.
<br>
------BAD------
{% highlight java %}
public class wheel
{
    int numSpokes;
    double diameter;

    public wheel(){}
    public wheel(int numSpokes, double diameter)
    {
        this.numSpokes = numSpokes;
        this.diameter = diameter;
    }

    public double area()
    {
        return diameter * Math.PI;
    }
}

public class BikeWheel extends wheel
{
int numSpokes;
double diameter;

public BikeWheel(int numSpokes, double diameter)
    {
        this.numSpokes = numSpokes;
        this.diameter = diameter;
    }

    public int area()
    {
        return (int) (diameter * Math.PI) / numSpokes;
    }
}
{% endhighlight %}
<br>
The preceding code is poorly written for several reasons, firstly the user expects BikeWheel to resemble a wheel in it's implementation but it's one method area() has two different returns types!! Secondly they're not ever similar in their function the first method returns the area of the wheel, the BikeWheel returns the area between each spoke. In a good example the child class would resemble the parent class much more.
<br>
<br>
The fourth principle, <a href = "http://en.wikipedia.org/wiki/Interface_segregation_principle"> The Interface Segregation Principle</a> talks about how an Interface should be implemented in client code, emphasizing how little wiggle room one large interface provides and how several smaller interfaces allow easy refactoring. And more importantly, the smaller interfaces allow for more focused grouping so when a client needs to find a certain method that relates to xyz, they simply just open the xyzInterface and see the exact methods, that apply to their desired domain.
<br>
<br>
Lastly, the <a href = "http://en.wikipedia.org/wiki/Dependency_inversion_principle"> Dependency Inversion Principle</a>. This principle earned it's name by 'inverting' the way people think about OOP (<a href = "http://en.wikipedia.org/wiki/Object-oriented_programming"> Object Oriented Programming</a>), because most people think of high-level components utilizing several low-level components leading to a system that gets more and more difficult to comprehend and -- usually -- becoming more capable. This principle dictates that this is not true and is in fact bad practice. For instance it's much cleaner code to have several objects of varying size which each extend the same basic class and apply varying levels of intricacy.Dependency Inversion suggests that high-level and low-level objects are separated into different packages and the high-order functions that will be used by the client are accompanied by an interface. In my opinion this is one of the most important principles to maintain code that not only fulfills the other SOLID principles but also greatly improves readability.
<br>
<br>